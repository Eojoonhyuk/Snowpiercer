## 리액트의 모든 훅 파헤치기

### useState

useState는 함수형 컴포넌트 내부에서 **상태를 정의**하고, **이 상태를 관리**할 수 있게 해주는 훅이다.

- useState의 인수로는 사용할 state의 초깃값을 넘겨준다. 초깃값을 넘겨주지 않으면 undefined

```jsx
function Component() {
  const [, triggerRender] = useState();

  let state = "hello";

  function handleButtonClick() {
    state = "hi";
    triggerRender();
  }

  return (
    <>
      <h1>{state}</h1>
      <button onClick={handleButtonClick}>hi</button>
    </>
  );
}
```

useState 반환값의 두 번째 원소를 실행해 리액트에서 렌더링이 일어나게끔 변경했지만 버튼 클릭 시 state의 변경된 값이 렌더링되고 있지 않다.

> 그 이유는 리액트의 렌더링은 함수형 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행되기 때문이다. 즉, 매번 렌더링이 발생될 때 마다 함수는 다시 새롭게 실행되고, 새롭게 실행되는 함수에서 state는 매번 hello로 초기화되므로 아무리 state를 변경해도 다시 hello로 초기화되는 것이다.

useState는 두 가지 값, 즉 현재 상태값과 상태를 갱신하는 함수를 반환한다. 여기서 중요한 점은 이 반환된 함수가 클로저를 형성한다는 것이다. 클로저란 함수가 선언될 당시의 환경을 기억하여 나중에 실행될 때 해당 환경에 접근할 수 있게 하는 것을 말한다.

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

여기서 increment 함수는 setCount를 호출하여 상태값을 갱신하는데, 이때 setCount는 클로저를 형성한다. 이 클로저는 count 변수를 기억하고 있어서 나중에 increment 함수가 호출될 때마다 이전 상태값을 사용하여 새로운 상태값을 계산할 수 있다. 이러한 동작은 함수 컴포넌트가 렌더링될 때마다 새로운 함수가 생성되어도 올바르게 동작하게끔 해준다.

클로저를 사용함으로써, 함수 컴포넌트 내에서 상태를 간편하게 관리할 수 있고, 이전 상태값을 쉽게 참조하여 새로운 상태값을 계산할 수 있게 된다.

### useEffect

- 리액트 코드를 작성할 때 useState만큼이나 자주 쓰는 훅이 바로 useEffect다.
- useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. 그리고 이 부수 효과가 '언제'일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다.

#### useEffect는 어떻게 의존성배열이 변경된 것을 알고 실행될까?

> 함수형 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다는 것을 기억하자. 즉, 함수형 컴포넌트는 렌더링 시마다 고유의 state와 props를 갖고 있다. 따라서 useEffect는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

#### 클린업 함수의 목적

- 클린업 함수는 새로운 값과 함께 렌더링된 뒤에 실행되자만 이 변경된 값을 읽는 것이 아니라 함수가 정의 됐을 당시에 선언됐던 이전 값을 보고 실행된다.
- 함수형 컴포넌트의 useEffect는 그 콜백이 실행될 때 마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행한다.
- 클린업 함수는 언마운트라기보다는 함수형 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해 주는 개념으로 보는 것이 옳다.

#### 의존성 배열

- 빈 배열일 경우 최초 렌더링 직후에 실행된 다음부터는 더 이상 실행되지 않는다.
- 아무런 값도 넘겨주지 않는다면 이때는 의존성 비교를 할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행된다.

#### useEffect의 구현

리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한번 더 수행한다. 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미한다.

```js
// Object.is는 참조가 다른 객체에 대해 비교가 불가능하다.
Object.is({ hello: "world" }, { hello: "world" }); // false

// 반면 리액트 팀에서 구현한 shallowEqual은 객체의 depth까지는 비교가 가능하다.
shallowEqual.is({ hello: "world" }, { hello: "world" }); // true

// 그러나 2 depth까지 가면 이를 비교할 방법이 없으므로 false를 반환한다.
shallowEqual.is({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false
```

useEffect의 본질은 이전 의존성 배열과 현재 의존성 배열의 값에 하나라도 변경 사항이 있다면 callback으로 선언한 부수 효과를 실행하는 것이다.

#### useEffect를 사용할 때 주의할 점

- eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제해라

```js
useEffect(() => {
  console.log(props);
}, []); // eslint-disable-line react-hooks/exhaustive-deps
```

useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅이다. 그러나 의존성 배열을 넘기지 않은 채 콜백 함수 내부에서 특정 값을 사용한다는 것은, 이 부수 효과가 실제로 관찰해서 실행돼야 하는 값과는 별개로 작동한다는 것을 의미한다. 즉, 컴포넌트의 state, props와 같은 어떤 값의 변경과 useEffect의 부수 효과가 별개로 작동하게 된다는 것이다.

**따라서 정말고 의존성으로 []가 필요하다면 최초에 함수형 컴포넌트가 마운트됐을 시점에만 콜백 함수 실행이 필요한지를 다시 한번 되물어봐야 한다.**

- useEffect의 첫 번째 인수에 함수명을 부여하라
  useEffect의 수가 적거나 복잡성이 낮다면 이러한 익명 함수를 사용해도 큰 문제는 없다. 그러나 useEffect의 코드가 복잡하고 많아질수록 무슨 일을 하는 useEffect 코드인지 파악하기 어려워진다. 이때 이useEffect의 인수를 익명 함수가 아닌 적절한 이름을 사용한 기명 함수로 바꾸는 것이 좋다.

```js
useffect(
  function logActiveUser() {
    logging(user.id);
  },
  [user.id]
);
```

- 거대한 useEffect를 만들지 마라
- 불필요한 외부 함수를 만들지 마라

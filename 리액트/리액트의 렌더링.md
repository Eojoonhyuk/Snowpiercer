# 렌더링이란?

리액트에서 렌더링이란, 컴포넌트가 현재 props와 state의 상태에 기초하여 UI를 어떻게 구상할지 요청하는 작업을 의미한다.

- 런타임: 특정 언어로 만든 프로그램들을 실행 할 수 있는 환경(ex. 자바스크립트 엔진, Web API, 콜백 큐, 이벤트 루프, 렌더 큐)

## 렌더링 과정

기본적인 리액트의 렌더링 개념은 루트`(<div id="root"></div>)` DOM부터 시작해 플래그가 지정되어 있는 모든 컴포넌트를 찾아서 렌더링을 진행하는 것을 말한다.

```javascript
const root = ReactDOM.createRoot(document.getElementById("root"));
const element = <h1>hello, world</h1>;
root.render(element);
```

### 리액트 엘리먼트

리액트 엘리먼트란 **type**과 **props**를 가지는 **React만의 객체**이다.

## 렌더와 커밋 단계

- 렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 과정이 이루어지는 단계

- 커밋 단계: 변경 사항을 실제로 DOM에 적용하는 단계

커밋 단계를 거쳐서 DOM을 업데이트하고 나면, React는 요청된 DOM 노드와 컴포넌트 인스턴스를 가리키도록 모든 참조사항들을 업데이트한다. 그리고나서 componentDidMount와 componentDidUpdate 클래스 생명주기 메소드 또는 useLayoutEffect 훅을 동기적으로 실행한다.

그 후 React는 짧은 타임 아웃을 세팅하고, 타임 아웃이 끝나면 모든 useEffect 훅을 실행한다. 이 단계는 **수동적 효과(Passive Effect)** 라고도 알려져 있다.

## 렌더링 순서 만들기

최초의 렌더가 끝난 이후, React가 리렌더링을 Queue에 넣돌혹 하는 방법은 여러가지가 있다.

- 함수형 컴포넌트
  useState setters
  useReducer dispatches

- 그 외
  ReactDOM.render(<App>) 을 다시 호출한다. (루트 컴포넌트에서 forceUpdate()를 호출하는 것과 동일)

## 일반적인 렌더링 동작

리액트의 기본적인 동작은 부모 컴포넌트가 렌더링되면, 리액트는 모든 자식 컴포넌트를 순차적으로 리렌더링한다.

일반적인 렌더링의 경우, 리액트는 props가 변경되어 있는지 신경쓰지 않는다. 부모 컴포넌트가 렌더링 되어 있기 때문에, 자식 컴포넌트도 무조건 리렌더링 된다.

## 컴포넌트 메타데이터와 Fibers

React는 현재 어플리케이션에 존재하는 모든 컴포넌트 인스턴스를 추적하는 내부 자료 구조를 갖고 있다. 이 자료 구조의 핵심 부분은 피버(Fiber)라고 불리는 객체이다. 피버에는 메터데이터 필드가 들어있는데, 이 메타데이터 필드에는 다음의 내용이 있다.

- 지금 현재 시점에서 컴포넌트 트리 안에서 렌더링 되어야 하는 컴포넌트 유형
- 이 컴포넌트와 관련되어있는 현재 Props와 State
- 부모, 형제 그리고 자식 컴포넌트를 향한 포인터
- React가 렌더링 과정을 추적하기 위해 필요한 다른 내부 데이터

렌더링 패스 과정 동안, React는 이 피버 객체의 트리를 순환할 것이고, 새로운 렌더링 결과물을 계산해서 나온 업데이트 된 트리를 생성한다.

이 피버 객체들은 실제 컴포넌트 Props와 State 값을 저장하고 있다는 점을 주목해야한다.
우리가 컴포넌트에서 Props와 State를 보는 것은, React가 피버 객체에 저장되어있는 값들을 볼 수 있게끔 허가 해주었기 때문에 가능한 것이다.

비슷하게, React 훅이 동작하는 이유는 React가 그 컴포넌트에서 쓰는 모든 훅들을 컴포넌트의 피버 객체와 연결된 연결 리스트로 만들어서 저장해놓았기 때문이다.

리액트가 함수형 컴포넌트를 렌더링할 때, React는 피버로부터 훅 관련 연결리스트를 받아온다. 다른 훅을 호출한다면 그 때마다 React는 훅 객체에 저장되어있는 값중 적절한 값을 찾아 반환한다.(state나 useReducer에서 사용하는 dispatch같은 값들)

부모 컴포넌트가 자식 컴포넌트를 처음으로 렌더링할 때, React는 인스턴스를 추적하기 위한 피버 객체를 생성한다. 함수형 컴포넌트에서는 YourComponentType(props)를 함수로 호출한다.

## 컴포넌트 타입과 재조정

React는 기존에 존재하는 컴포넌트 트리와 DOM 구조를 최대한 재활용해서, 최대한 효율적으로 리렌더링을 진행하려고 한다. 만약 React가 같은 유형의 컴포넌트 또는 HTML 노드를 트리의 동일한 위치에 렌더링 해야한다면, React는 새로 만들어내는 대신의 기존의 것을 재사용 하려고 할 것이다. 이는 즉 같은 위치에 같은 유형의 컴포넌트를 렌더링하도록 요청이 들어오는 동안 React는 컴포넌트 인스턴스를 계속 유지한다는 것이다.

그렇다면 결과물이 언제 그리고 어떻게 변경되었는지를 React가 어떻게 알 수 있을까?

React의 렌더링 로직은 먼저 type 필드에 기반하여 엘리먼트를 비교한다. 이 때 === 같은 참조 비교를 사용한다. 만약 어떤 엘리먼트가 다른 타입으로 변경되었다면, React는 전체 트리가 변경되었다고 가정하고 비교 절차의 속도를 높일 것이다. 결과적으로 React는 모든 DOM 노드를 포함하여 현재 존재하는 모든 컴포넌트 트리 영역을 파괴할 것이다. 그리고 나서 새로운 컴포넌트 인스턴스로 다시 만들어 나갈 것이다.

이는 렌더링이 일어나는 동안에는 새로운 컴포넌트 유형을 생성해서는 안된다는 것을 의미한다. 새로운 컴포넌트 유형을 만들면 이는 모두 다른 참조를 갖고, React는 계속해서 자식 컴포넌트 트리를 파괴하고 다시 만들 것이기 때문이다.

## 렌더링 배치와 타이밍

기본적으로, setState()가 호출되면 React는 새로운 렌더링 패스를 시작하고, 동기적으로 실행하여 반환한다. 하지만 React는 또한 렌더링 배치 형식의 최적화를 자동적으로 적용한다. 여기서 이 렌더링 배치는 다수의 setState() 호출로 인해 단일 렌더링 패스가 대기열에 저장되고 실행되는 경우를 얘기하며, 일반적으로 약간의 지연이 발생한다.

React 공식문서에서는 상태 업데이트는 아마도 비동기적으로 발생한다고 언급되어있다. 이는 렌더링 배치를 말하는 것이다. 특히, React는 자동적으로 React 이벤트 핸들러에서 발생하는 상태 업데이트를 일괄처리 한다.

# 람다식
- 람다식은 메서드를 하나의 식으로 표현하는 문법이다. 자바에서 보통 메서드를 만들려면 클래스 -> 메서드 -> 객체 생성까지 필요했지만, 람다식을 쓰면 코드가 훨씬 짧아진다.


### 기존 방식(익명 클래스)

```java
Runnable task = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};
```

### 람다식 방식

```java
Runable task = () -> System.out.println("Hello");
```

# 람다식 문법

```text
(매개변수) -> {실행문}
```

```java
(int a, int b) -> {return a + b};
```

- 매개변수 타입은 생략 가능
- 실행문이 한줄이면  {}와 return도 생략 가능

# 함수형 인터페이스
- 람다식은 함수형 인터페이스 타입으로만 사용 가능하다. 함수형 인터페이스란 추상 메서드가 딱 1개 있는 인터페이스

### 예시

```java
@FunctionalInterface
interface Calculator {
    int add(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        Calculator c = (x, y) -> x + y;  // 람다식 구현
        System.out.println(c.add(5, 3));  // 8
    }
}
```

# 람다식과 변수 캡쳐
- 람다식은 외부 변수(지역 변수)를 사용할 수 있지만, 값은 변경 불가(실질적 final, 값이 계속 바뀌면 일관성이 깨질 수 있기 때문)이다.

```java
public class Main {
    public static void main(String[] args) {
        int num = 10;  // 람다식 밖의 지역 변수

        Runnable r = () -> {
            System.out.println("num 값: " + num);
            // num = 20;  // ❌ 컴파일 오류: 람다 내부에서 값 변경 불가
        };

        r.run();
    }
}
```

# 메서드 참조
- 람다식이 기존 메서드 호출만 할 경우 메서드 참조로 더 간단히 표현 가능하다.

```java
list.forEach(s -> System.out.println(s));
// 메서드 참조
list.forEach(System.out::println);
```

# 생성자 참조
- 람다식이 객체 생성만 하는 경우 클래스명::new 로 표현할 수 있습니다.

```java
Supplier<Person> s = Person::new; // Person 생성자 참조
Person p = s.get();
```

# 자바가 제공하는 주요 함수형 인터페이스
- 자바 8에서는 java.utils.function 패키지에 함수형 인터페이스를 미리 정희해 놓았습니다.

### 자바의 주요 함수형 인터페이스 (java.util.function)

| 인터페이스        | 설명                              | 메서드 시그니처         | 예시 사용법                          |
|-------------------|-----------------------------------|-------------------------|---------------------------------------|
| Supplier<T>       | 값을 공급 (리턴만 있고 입력 없음)  | `T get()`               | `Supplier<String> s = () -> "Hi";`    |
| Consumer<T>       | 값을 소비 (입력만 있고 리턴 없음)  | `void accept(T t)`      | `Consumer<Integer> c = x -> System.out.println(x);` |
| Function<T, R>    | T를 R로 변환 (입력 → 리턴)        | `R apply(T t)`          | `Function<Integer, String> f = x -> "Num: " + x;` |
| Predicate<T>      | 조건 검사 (true/false 반환)        | `boolean test(T t)`     | `Predicate<Integer> p = x -> x > 10;` |
| BiFunction<T, U, R> | T와 U를 입력받아 R로 변환       | `R apply(T t, U u)`     | `BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;` |
| UnaryOperator<T>  | 입력 타입과 출력 타입이 동일한 Function | `T apply(T t)`        | `UnaryOperator<Integer> square = x -> x * x;` |
| BinaryOperator<T> | 같은 타입 2개 입력 → 같은 타입 출력 | `T apply(T t1, T t2)` | `BinaryOperator<Integer> add = (a, b) -> a + b;` |

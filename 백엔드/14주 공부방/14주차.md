# 제네릭이란?
- 제네릭은 클래스나 메서드가 사용할 데이터 타입을 미리 지정하지 않고, 객체 생성 시점에 타입을 지정할 수 있는 기능이다.

```java
ArrayList<String> list = new ArrayList<>();
list.add("Hello");
String str = list.get(0); // 타입 캐스팅 필요 없음
```

- <Stirng> 부분이 제네릭 타입이다.
- 타입 안정성을 보장한다. 잘못된 타입을 넣으면 컴파일 시점에서 에러 발생

# 제네릭을 쓰지 않을 때의 문제점

```java
ArrayList list = new ArrayList();  // 타입 지정 안 함
list.add("Hello");
list.add(100); // 문자열 아닌 정수도 추가 가능 (오류 가능성 ↑)

String s = (String) list.get(1); // 런타임 오류 발생 가능 (ClassCastException)
```

문제점
- 잘못된 타입이 들어가도 컴파일러가 잡아주지 못함
- 꺼낼 때 매번 (String)처럼 타입 캐스팅 필요

# 제네릭 클래스 정의하기

```java
class Box<T> {    // T는 타입 파라미터
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```

```java
Box<String> box1 = new Box<>();
box1.setValue("Hello");
System.out.println(box1.getValue()); // "Hello"

Box<Integer> box2 = new Box<>();
box2.setValue(100);
System.out.println(box2.getValue()); // 100
```

- T는 클래스를 생성할 때 정해질 실제 탕비으로 대체된다.

# 제네릭 메서드
- 클래스 전체가 제네릭이 아니어도, 메서드 단위로 제네릭을 정의할 수 있다.

```java
public <T> void printItem(T item) {
    System.out.println(item);
}

printItem("Hello"); // T = String
printItem(123);     // T = Integer
```

# 바운디드 타입
<T extends 클래스>를 사용해서 제네릭 타입에 제한을 둘 수 있다.

```java
class NumberBox<T extends Number> { // Number 또는 Number 자식 타입만 가능
    private T num;

    public void setNum(T num) {
        this.num = num;
    }

    public T getNum() {
        return num;
    }
}

NumberBox<Integer> intBox = new NumberBox<>(); // OK
NumberBox<String> strBox = new NumberBox<>();  // ❌ String은 Number를 상속하지 않음
```

# 와일드카드(?)
- ?는 알 수 없는 타입을 의미
- 메서드에서 다양한 제네릭 타입을 받을 때 사용

```java
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```

# 제네릭과 타입소거
- 제네릭은 컴파일 시점에만 타입을 체크하고, 런타임에는 타입 정보가 제거된다.
- 즉, Box<String>과 Box<Integer>는 런타임에는 같은 클래스 Box로 동작

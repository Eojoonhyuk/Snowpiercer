# 상속
> 상속은 기존 클래스의 속성과 기능을 물려받아 새로운 클래스를 만드는 것
- 기존 클래스 -> 부모 클래스(또는 슈퍼 클래스)
- 새로운 클래스 -> 자식 클래스(또는 서브 클래스)

```java
  class 부모클래스{ ... }
  class 자식클래스 extends 부모클래스 { ... }
```

# extends 키워드
- 자식 클래스가 부모 클래스를 상속받을 때 사용
- 부모 클래스의 필드와 메서드를 물려받아 사용 가능

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("멍멍!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
        d.bark();
    }
}
```

# super 키워드
- super는 부모 클래스의 필드나 메서드, 생성자 등을 호출할 때 사용한다.

```java
public class Animal {
    Animal() {
        System.out.println("동물이 태어났습니다");
    }
}

public class Dog extends Animal {
    Dog() {
        super();  // Animal() 생성자 호출
        System.out.println("강아지가 태어났습니다");
    }
}
```

- super.메서드명() => 부모의 메서드 호출

```java
class Animal {
    void sound() {
        System.out.println("동물 소리");
    }
}

class Cat extends Animal {
    void sound() {
        super.sound();         // Animal의 sound 호출
        System.out.println("야옹");
    }
}

```

# 메서드 오버라이딩
부모 클래스의 메서드를 자식 클래스가 재정의해서 사용하는 것

```java
class Animal {
    void sound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

```

# 다형성과 다이나믹 메서드 디스패치

## 다형성
- 부모 타입 변수로 자식 객체를 다룰 수 있는 것
- 실행 시점에 객체의 타입을 기준으로 메서드가 결정됨 → 동적 바인딩

## 왜 쓰는 걸까?
- 공통된 인터페이스(타입)로 다루면 코드가 유연해진다.
- 확장성이 높고, 유지보수 쉬운 코드를 만들 수 있다.
- 여러 자식 객체를 하나의 부모 타입으로 통합해서 관리할 수 있다. 

# 다이나믹 메서드 디스패치
- 다형성 상태에서, 오버라이딩된 메서드를 실행할 때, 실행 시점에 실제로 객체의 타입을 기준으로 메서드를 선택하는 것

## 컴파일 타임 vs 런타임
- 컴파일 타임: a는 Animal → sound() 메서드 있는지만 확인
- 런타임: 실제 a가 Dog면 → Dog의 sound() 실행됨. 즉, 메서드 호출이 실행 시간에 결정된다

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹~");
    }
}
```
```java
public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.sound();  // 멍멍!
        a2.sound();  // 야옹~
    }
}
```

- a1, a2는 모두 Animal 타입이지만
- 실제 객체는 Dog, Cat
- 호출되는 sound()는 실제 객체 기준으로 실행됨
- 이것을 다이나믹 메서드 디스패치라고 한다.

# 추상 클래스
- 상속을 위한 틀만 제공하고, 직접 객체로 만들 수 없음
- 자식 클래스가 반드시 메서드를 구현해야함
- 공통적인 틀은 제공하고, 세부 구현은 자식이 하도록 강제하기 위해

```java
abstract class Animal {
    String name;

    Animal(String name){
        this.name = name;
    }

    void eat(){
        System.out.println(name + "이(가) 밥을 먹어요");
    }

    abstract void sound();
}

class Dog extends Animal {
    Dog(String name){
        super(name);
    }
    
    @Override
    void sound(){
        System.out.println("멍멍!");
    }
}

class Cat extends Animal{
    Cat(String name){
        super(name);
    }
    
    void sound(){
        System.out.println("야옹!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog("초코");
        Animal a2 = new Cat("나비");
        
        a1.eat();
        a1.sound();
        
        a2.eat();
        a2.sound();
    }
}
```

# final 키워드

|위치|의미|
|-----|-----|
|final class|상속 불가|
|final method|오버라이딩 불가|
|final variable|값 변경 불가(상수)|


# 모든 클래스의 조상 Object
- 자바의 모든 클래스는 Object 클래스를 자동으로 상속한다.
- toString(), equals(), hashCode() 등은 Object의 메서드

## 변수 호이스팅
### var
var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.

var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 "선언 단계"와 "초기화 단계"가 한번에 진행된다. 즉, 선언단계에서 스코프(실행 컨텍스트의 렉시컬 환경)에 변수 식별자를 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 그리고 즉시 초기화 단계에서 undefined로 변수를 초기화 한다.

### let
var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
```js
  console.log(foo) // ReferenceError: foo is not defined
  let foo
```
let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 진행되지만 초기화 단계는 변수 선언문에 도달했을 떄 실행 된다.
let 키워드로 선언한 변수는 스코프 시작 지점부터 초기화 시작 지점(변수 선언문)까지 변수를 참조할 수 없다. 이 구간을 일시적 사각지대(TDZ)라고 부른다.

### const
const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

## 함수 호이스팅
```js
// 함수 참조
  console.log(add) // f add(x, y)
  console.log(sub) // undefined

// 함수 호출
  console.log(add(2,5)) // 7
  console.log(sub(2,5)) // TypeError: sub is not a function

// 함수 선언문
  function add(x, y){
    return x + y
}

// 함수 표현식
  var sub = function(x, y){\
    return x - y
}

```

함수 선언문으로 정희한 함수는 함수 선언문 이전에 호출할 수 있다. 함수 표현식으로 정의한 함수는 함수 표현식 이전의 호출할 수 없다. 이는 함수 생성 시점이 다르기 때문이다.
함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다. 이를 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.

## 변수 호이스팅과 함수 호이스팅의 차이
변수 선언문과 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서는 동일하다. 하지만 var 키워드로 선언된 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.

함수 표현식은 변수에 할당되는 값이 함수 리터럴이다. 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하다. 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
**따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.**
